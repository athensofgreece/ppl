int isKeyword(char *lexeme) {
    int current_state = 0; // Initial state
    int i = 0;

    while (lexeme[i] != '\0') {
        switch (current_state) {
            case 0: // Initial state
                switch (lexeme[i]) {
                    case 'b': current_state = 1; break;
                    case 'c': current_state = 16; break;
                    case 'd': current_state = 20; break;
                    case 'e': current_state = 28; break;
                    case 'f': current_state = 34; break;
                    case 'g': current_state = 37; break;
                    case 'h': current_state = 43; break;
                    case 'i': current_state = 51; break;
                    case 'q': current_state = 53; break;
                    case 'r': current_state = 61; break;
                    case 's': current_state = 67; break;
                    case 'w': current_state = 77; break;
                    default: return 0; // Not a keyword
                }
                break;

            case 1: // 'b'
                switch (lexeme[i]) {
                    case 'e': current_state = 2; break;
                    case 'u': current_state = 10; break;
                    default: return 0;
                }
                break;
            case 2: // 'be'
                current_state = (lexeme[i] == 'e') ? 3 : 0;
                break;
            case 3: // 'bee'
                current_state = (lexeme[i] == 'g') ? 4 : 0;
                break;
            case 4: // 'beeg'
                switch (lexeme[i]) {
                    case 'i': current_state = 5; break;
                    case 'o': current_state = 7; break;
                    default: return 0;
                }
                break;
            case 5: // 'beegi'
                current_state = (lexeme[i] == 'n') ? 6 : 0;
                break;
            case 6: // Final state for 'beegin'
                return (lexeme[i] == '\0') ? 1 : 0;
            case 7: // 'beego'
                current_state = (lexeme[i] == 'n') ? 8 : 0;
                break;
            case 8: // 'beegon'
                current_state = (lexeme[i] == 'e') ? 9 : 0;
                break;
            case 9: // Final state for 'beegone'
                return (lexeme[i] == '\0') ? 1 : 0;
            case 10: // 'bu'
                current_state = (lexeme[i] == 'z') ? 11 : 0;
                break;
            case 11: // 'buz'
                current_state = (lexeme[i] == 'z') ? 12 : 0;
                break;
            case 12: // 'buzz'
                switch (lexeme[i]) {
                    case '\0': return 1; // Final state for 'buzz'
                    case 'o': current_state = 13; break;
                    default: return 0;
                }
                break;
            case 13: // 'buzzo'
                current_state = (lexeme[i] == 'u') ? 14 : 0;
                break;
            case 14: // 'buzzou'
                current_state = (lexeme[i] == 't') ? 15 : 0;
                break;
            case 15: // Final state for 'buzzout'
                return (lexeme[i] == '\0') ? 1 : 0;

            // States for 'case'
            case 16: // 'c'
                current_state = (lexeme[i] == 'a') ? 17 : 0;
                break;
            case 17: // 'ca'
                current_state = (lexeme[i] == 's') ? 18 : 0;
                break;
            case 18: // 'cas'
                current_state = (lexeme[i] == 'e') ? 19 : 0;
                break;
            case 19: // Final state for 'case'
                return (lexeme[i] == '\0') ? 1 : 0;

            // States for 'do' and 'default'
            case 20: // 'd'
                switch (lexeme[i]) {
                    case 'o': current_state = 21; break;
                    case 'e': current_state = 22; break;
                    default: return 0;
                }
                break;
            case 21: // Final state for 'do'
                return (lexeme[i] == '\0') ? 1 : 0;
            case 22: // 'de'
                current_state = (lexeme[i] == 'f') ? 23 : 0;
                break;
            case 23: // 'def'
                current_state = (lexeme[i] == 'a') ? 24 : 0;
                break;
            case 24: // 'defa'
                current_state = (lexeme[i] == 'u') ? 25 : 0;
                break;
            case 25: // 'defau'
                current_state = (lexeme[i] == 'l') ? 26 : 0;
                break;
            case 26: // 'defaul'
                current_state = (lexeme[i] == 't') ? 27 : 0;
                break;
            case 27: // Final state for 'default'
                return (lexeme[i] == '\0') ? 1 : 0;

            // States for 'else'
            case 28: // 'e'
                current_state = (lexeme[i] == 'l') ? 29 : 0;
                break;
            case 29: // 'el'
                current_state = (lexeme[i] == 's') ? 30 : 0;
                break;
            case 30: // 'els'
                current_state = (lexeme[i] == 'e') ? 31 : 0;
                break;
            case 31: // Final state for 'else'
                switch (lexeme[i]) {
                    case '\0': return 1;
                    case 'i': current_state = 32; break;
                    default: return 0;
                }
                break;
            case 32: // 'elsei'
                current_state = (lexeme[i] == 'f') ? 33 : 0;
                break;
            case 33: // Final state for 'elseif'
                return (lexeme[i] == '\0') ? 1 : 0;

            case 34: //states for 'for'
                current_state = (lexeme [i] == 'o') ? 35 : 0;
                break;
            case 35:
                current_state = (lexeme[i] == 'r') ? 36 : 0;
                break;
            case 36: //for
                return (lexeme[i] == '\0') ? 1 : 0;
                
            case 37: //start state for gather
                current_state = (lexeme [i] == 'a') ? 38 : 0;
                break;
            case 38: //ga
                current_state (lexeme [i] == 't') ? 39 : 0;
                break;
            case 39: //gat
                current_state = (lexeme [i] == 'h') ? 40 : 0;
                break;
            case 40:
                current_state = (lexeme[i] == 'e') ? 41 : 0;
                break;
            case 41:
                current_state = (lexeme[i] == 'r') ? 42 : 0;
                break;
            case 42: //final state for gather
                return (lexeme[i] == '\0') ? 1 : 0
            case 43: //h | ho | hi
                switch (lexeme [i]) {
                    case 'i': current_state = 44; break;
                    case 'o' : current_state = 47; break;
                    default: return 0;
                }
            case 44:
                current_state = (lexeme [i] == 'v') ? 45 : 0;
                break; ? 46 : 0;
                break;
            case 46: 
            case 45:
                current_state = (lexeme [i] == 'e') ? 46 : 0;
                break;
            case 46: 
                return (lexeme[i] == '\0') ? 1 : 0;

            case 47:
                current_state = (lexeme [i] == 'v') ? 48 : 0;
                break;
            case 48: 
                current_state = (lexeme [i] == 'e') ? 49 : 0;
                break;
            case 49:
                current_state = (lexeme [i] == 'r') ? 50 : 0;
                break;
            case 50:
                return (lexeme[i] == '\0') ? 1 : 0;
            
            case 51:
                current_state = (lexeme [i] == 'f') ? 52 : 0;
                break;
            case 52:
                return (lexeme[i] == '\0') ? 1 : 0;
            
            case 53: //queenbee
                current_state = (lexeme [i] == 'u') ? 54 : 0;
                break;
            case 54:
                current_state = (lexeme [i] == 'e') ? 55 : 0;
                break;
            case 55:
                current_state = (lexeme [i] == 'e') ? 56 : 0;
                break;
            case 56:
                current_state = (lexeme [i] == 'n') ? 57 : 0;
                break;
            case 57:
                current_state = (lexeme [i] == 'b') ? 58 : 0;
                break;
            case 58:
                current_state = (lexeme [i] == 'e') ? 59 : 0;
                break;
            case 59:
                current_state = (lexeme [i] == 'e') ? 60 : 0;
                break;
            case 60: //finak state for queenbee
                return (lexeme[i] == '\0') ? 1 : 0;

            case 61: //starting state for 'return'
                current_state = (lexeme [i] == 'e') ? 62 : 0;
                break;
            case 62:
                current_state = (lexeme [i] == 't') ? 63 : 0;
                break;
            case 63:
                current_state = (lexeme [i] == 'u') ? 64 : 0;
                break;
            case 64:
                current_state = (lexeme [i] == 'r') ? 65 : 0;
                break;
            case 65:
                current_state = (lexeme [i] == 'n') ? 66 : 0;
                break;
            case 66: // final state for return
                return (lexeme[i] == '\0') ? 1 : 0;
            
            case 67: // switch and sting
                switch (lexeme[i]){
                    case 't': current_state = 68; break;
                    case 'w' : current_state = 72; break;
                    default: return 0;
                }
            case 68:
                current_state = (lexeme [i] == 'i') ? 69 : 0;
                break;
            case 69:
                current_state = (lexeme [i] == 'n') ? 70 : 0;
                break;
            case 70:
                current_state = (lexeme [i] == 'g') ? 71 : 0;
                break;
            case 71:
                return (lexeme[i] == '\0') ? 1 : 0;
            
            case 72: // switch
                current_state = (lexeme [i] == 'i') ? 73 : 0;
                break;
            case 73:
                current_state = (lexeme [i] == 't') ? 74 : 0;
                break;
   
            case 74: 
                current_state = (lexeme [i]) == 'c') ? 75 : 0;
                break;
            case 75: 
                current_state = (lexeme [i]) == 'h') ? 76 : 0;
                break; 
            case 76: //final state for switch
                return (lexeme[i] == '\0') ? 1 : 0;
            
            case 77: // starting state for while
                current_state = (lexeme [i]) == 'h') ? 78 : 0;
                break;
            case 78:
                current_state = (lexeme [i]) == 'i') ? 79 : 0;
                break;
            case 79:
                current_state = (lexeme [i]) == 'l') ? 80: 0;
                break;
            case 80:
                current_state = (lexeme [i]) == 'e') ? 81 : 0;
            case 81: //final state for while
                return (lexeme [i] == '\0') ? 1 : 0;

            default:
                return 0; // Not a valid keyword
        }
        i++;
    }

    return 0; // If not accepted by the DFA
}
