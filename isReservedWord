typedef enum {
    INITIAL_STATE = 0,
    // States for 'bool'
    Q1, Q2, Q3, Q4,              // b-o-o-l
    // States for 'chain' and 'char'
    Q5, Q6, Q7,                  // c-h-a
    Q8, Q9,                      // i-n (chain)
    Q10,                         // r (char)
    // States for 'false' and 'float'
    Q11,                         // f
    Q12, Q13, Q14, Q15,         // a-l-s-e (false)
    Q16, Q17, Q18, Q19,         // l-o-a-t (float)
    // States for 'int'
    Q20, Q21, Q22,              // i-n-t
    // States for 'true'
    Q23, Q24, Q25, Q26          // t-r-u-e
} State;

int isReservedWord(char *lexeme, char ch, int *type) {
    initial_state = 0;;
    int i = 0;

    while (lexeme[i] != '\0') {
        switch (current_state) {
            case INITIAL_STATE:
                switch (lexeme[i]) {
                    case 'b': current_state = Q1; break;
                    case 'c': current_state = Q5; break;
                    case 'f': current_state = Q11; break;
                    case 'i': current_state = Q20; break;
                    case 't': current_state = Q23; break;
                    default: return 0;
                }
                break;

            // States for 'bool'
            case Q1:
                if (lexeme[i] == 'o') current_state = Q2;
                else return 0;
                break;
            case Q2:
                if (lexeme[i] == 'o') current_state = Q3;
                else return 0;
                break;
            case Q3:
                if (lexeme[i] == 'l') current_state = Q4;
                else return 0;
                break;

            // States for 'chain' and 'char'
            case Q5:
                if (lexeme[i] == 'h') current_state = Q6;
                else return 0;
                break;
            case Q6:
                if (lexeme[i] == 'a') current_state = Q7;
                else return 0;
                break;
            case Q7:
                if (lexeme[i] == 'i') current_state = Q8;
                else if (lexeme[i] == 'r' && lexeme[i + 1] == '\0') current_state = Q10;
                else return 0;
                break;
            case Q8:
                if (lexeme[i] == 'n') current_state = Q9;
                else return 0;
                break;

            // States for 'false' and 'float'
            case Q11:
                if (lexeme[i] == 'a') current_state = Q12;
                else if (lexeme[i] == 'l') current_state = Q16;
                else return 0;
                break;
            case Q12:
                if (lexeme[i] == 'l') current_state = Q13;
                else return 0;
                break;
            case Q13:
                if (lexeme[i] == 's') current_state = Q14;
                else return 0;
                break;
            case Q14:
                if (lexeme[i] == 'e') current_state = Q15;
                else return 0;
                break;
            case Q16:
                if (lexeme[i] == 'o') current_state = Q17;
                else return 0;
                break;
            case Q17:
                if (lexeme[i] == 'a') current_state = Q18;
                else return 0;
                break;
            case Q18:
                if (lexeme[i] == 't') current_state = Q19;
                else return 0;
                break;

            // States for 'int'
            case Q20:
                if (lexeme[i] == 'n') current_state = Q21;
                else return 0;
                break;
            case Q21:
                if (lexeme[i] == 't') current_state = Q22;
                else return 0;
                break;

            // States for 'true'
            case Q23:
                if (lexeme[i] == 'r') current_state = Q24;
                else return 0;
                break;
            case Q24:
                if (lexeme[i] == 'u') current_state = Q25;
                else return 0;
                break;
            case Q25:
                if (lexeme[i] == 'e') current_state = Q26;
                else return 0;
                break;
        }
        i++;
    }

    // Check final state and assign token type
    switch (current_state) {
        case Q4:  *type = BOOL_TOKEN; return 1;   // bool
        case Q9:  *type = CHAIN_TOKEN; return 1;  // chain
        case Q10: *type = CHAR_TOKEN; return 1;   // char
        case Q15: *type = FALSE_TOKEN; return 1;  // false
        case Q19: *type = FLOAT_TOKEN; return 1;  // float
        case Q22: *type = INT_TOKEN; return 1;    // int
        case Q26: *type = TRUE_TOKEN; return 1;   // true
        default:  return 0;
    }
}
